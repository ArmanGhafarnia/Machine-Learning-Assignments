# -*- coding: utf-8 -*-
"""second_ML-HW4.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1CMi-Rp8PemOR_BlfDMO5gqmpD1uyPEYo
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import math

data_set = pd.read_csv('/content/drive/MyDrive/ML - HW4/d2.csv')    #read table
data_set.head()

data_set_values = data_set[['x', 'y']].values
x = data_set_values[:, 0]
y = data_set_values[:, -1]      # values of x and y
plt.scatter(x,y)
plt.show()

E = 0.105
min_points = 4
Num_of_group = 0
N = len(data_set_values)

def extend(points_cluster, neighborhood):
  for point in neighborhood:
      if points_cluster[point] == -10:           # neighbor point is border
          points_cluster[point] = Num_of_group
          continue

      if points_cluster[point] == -1:           # if point is not checked
          points_cluster[point] = Num_of_group
          num_second_degree_neighbors = 0
          for j in range(N):
              if np.sqrt(np.sum(pow((data_set_values[point] - data_set_values[j]), 2))) < E:
                  num_second_degree_neighbors +=1            # count number of neighbors

          if num_second_degree_neighbors >= min_points:     # if the neighbor is core point too
               for i in range(N):
                if np.sqrt(np.sum(pow((data_set_values[point] - data_set_values[i]), 2))) < E:
                  neighborhood.append(i)                    # merge the neighborhood of them

points_cluster = []
for k in data_set_values:
    points_cluster.append(-1)           # consider all points unchecked

for i in range(N):
    if points_cluster[i] == -1:       # if point is not checked
      neighborhood = []
      for j in range(N):
        if np.sqrt(np.sum(pow((data_set_values[i] - data_set_values[j]),2))) < E:   # if 2nd point is neighbor or not
          neighborhood.append(j)
      if len(neighborhood) < min_points:   # point is border or noise
          points_cluster[i] = -10
      if len(neighborhood) >= min_points : # core point
          Num_of_group += 1
          points_cluster[i] = Num_of_group
          extend(points_cluster, neighborhood)  # extend the neighbors

plt.scatter(x,y , c = points_cluster, cmap='prism')
plt.show()